library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity clock_to_lcd is
    port (
        clk_50mhz      : in  std_logic;
        reset          : in  std_logic;
        seconds_in    : in  std_logic_vector(6 downto 0);
        minutes_in    : in  std_logic_vector(6 downto 0);
        hours_in      : in  std_logic_vector(6 downto 0);
        buzz          : in  std_logic;
        
        -- LCD Interface Signals
        lcd_data      : out std_logic_vector(7 downto 0);
        lcd_rs        : out std_logic;
        lcd_rw        : out std_logic;
        lcd_en        : out std_logic;
        lcd_blon      : out std_logic  -- Backlight control
    );
end clock_to_lcd;

architecture Behavioral of clock_to_lcd is
    -- LCD Controller States
    type lcd_state_type is (
        INIT,
        FUNCTION_SET,
        DISPLAY_ON,
        DISPLAY_CLEAR,
        MODE_SET,
        WRITE_TIME,
        DONE
    );
    
    signal state      : lcd_state_type := INIT;
    signal next_state : lcd_state_type;
    
    -- Timekeeping signals
    signal seconds    : integer range 0 to 59;
    signal minutes    : integer range 0 to 59;
    signal hours      : integer range 0 to 23;
    
    -- LCD Control Signals
    signal lcd_enable : std_logic;
    signal lcd_bus    : std_logic_vector(7 downto 0);
    signal lcd_busy   : std_logic := '1';
    
    -- Timing signals
    signal timer      : integer range 0 to 750000 := 0;
    signal delay_done : std_logic;
    
begin
    -- Convert input vectors to integers
    seconds <= to_integer(unsigned(seconds_in));
    minutes <= to_integer(unsigned(minutes_in));
    hours   <= to_integer(unsigned(hours_in));
    
    -- Backlight always on
    lcd_blon <= '1';
    
    -- LCD Read/Write (always write)
    lcd_rw <= '0';
    
    -- Main LCD Control Process
    process(clk_50mhz, reset)
    begin
        if reset = '0' then
            state <= INIT;
            lcd_enable <= '0';
            lcd_bus <= (others => '0');
            timer <= 0;
        elsif rising_edge(clk_50mhz) then
            case state is
                when INIT =>
                    if timer < 750000 then  -- 15ms delay
                        timer <= timer + 1;
                        state <= INIT;
                    else
                        timer <= 0;
                        lcd_bus <= "00111000"; -- Function set: 8-bit, 2-line, 5x8 dots
                        state <= FUNCTION_SET;
                    end if;
                    
                when FUNCTION_SET =>
                    if timer < 12 then  -- 250ns delay
                        timer <= timer + 1;
                        state <= FUNCTION_SET;
                        lcd_enable <= '1';
                    else
                        timer <= 0;
                        lcd_enable <= '0';
                        lcd_bus <= "00001100"; -- Display on, cursor off, blink off
                        state <= DISPLAY_ON;
                    end if;
                    
                when DISPLAY_ON =>
                    if timer < 12 then
                        timer <= timer + 1;
                        state <= DISPLAY_ON;
                        lcd_enable <= '1';
                    else
                        timer <= 0;
                        lcd_enable <= '0';
                        lcd_bus <= "00000001"; -- Clear display
                        state <= DISPLAY_CLEAR;
                    end if;
                    
                when DISPLAY_CLEAR =>
                    if timer < 205 then  -- 4.1ms delay
                        timer <= timer + 1;
                        state <= DISPLAY_CLEAR;
                        lcd_enable <= '1';
                    else
                        timer <= 0;
                        lcd_enable <= '0';
                        lcd_bus <= "00000110"; -- Entry mode set
                        state <= MODE_SET;
                    end if;
                    
                when MODE_SET =>
                    if timer < 12 then
                        timer <= timer + 1;
                        state <= MODE_SET;
                        lcd_enable <= '1';
                    else
                        timer <= 0;
                        lcd_enable <= '0';
                        state <= WRITE_TIME;
                    end if;
                    
                when WRITE_TIME =>
                    -- Display time in format HH:MM:SS
                    -- First character (hours tens)
                    lcd_rs <= '1';  -- Data mode
                    lcd_bus <= std_logic_vector(to_unsigned(48 + (hours / 10), 8));
                    lcd_enable <= '1';
                    
                    -- Subsequent characters would be handled similarly
                    -- This is simplified - in practice you'd need a more complex
                    -- state machine to handle all characters
                    state <= DONE;
                    
                when DONE =>
                    lcd_enable <= '0';
                    -- Stay in this state until reset
            end case;
        end if;
    end process;
    
    -- Assign outputs
    lcd_data <= lcd_bus;
    lcd_en   <= lcd_enable;
    
    -- Optional: Add a process to handle the alarm buzz on LCD
    -- Could display "ALARM" when buzz is active
end Behavioral;